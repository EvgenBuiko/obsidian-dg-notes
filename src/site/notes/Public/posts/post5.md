---
{"dg-publish":true,"permalink":"/public/posts/post5/","title":"Асинхроннно = параллельно. Нет асинхронно = отложенное. Но что же там внутри? [[post5|Read]]","tags":["blog","Dev","C","Cplusplus"]}
---

В посте будет рассмотрена стековая реализация. Впринципе остальные реализации будут отличаться по сути только методом хранения состояния выполнения.
# Интересная историческая справка

Вырезки с переведённым текстом от программиста сетевых тулов (ssh, telnet и прочее) Саймона Тэтхема:

> Одна из часто возникающих проблем заключается в следующем: если у вас есть фрагмент кода, создающий данные, и другой фрагмент кода, потребляющий их, какой из них должен быть вызывающим, а какой — вызываемым?

В то время это был довольно распространённый вопрос и Дональд Кнут об этом написал текст в своей книге "Искусство программирования".

>В книге «Искусство программирования» Дональд Кнут предлагает решение подобной проблемы. Его ответ — полностью отказаться от концепции стека. Перестаньте думать об одном процессе как о вызывающем, а о другом — как о вызываемом, и начните рассматривать их как взаимодействующие равноправные процессы.
>....
>Теоретически это очень хорошо, но на практике это можно реализовать только на ассемблере, поскольку ни один распространённый язык высокого уровня не поддерживает примитив вызова СОПРОГРАММЫ. Как это реализовать? 

И тут Саймон вспоминает такой Сишный трюк как метод Даффа. 

Том Дафф - программист работавший с графикой. Придумал прозрачность грубо говоря. Интересный момент: во время создания прозразности работал в лабе Lucasfilm и там же сделал метод Даффа

# К реализации


<div class="transclusion internal-embed is-loaded"><div class="markdown-embed">



## Метод Даффа

Код просто i перебирает с 0 до 11
```c
#include <iostream>

int main() {
  int number = 11; // общее число итераций все еще равно 11.
  int count = number / 4; // число итераций развернутого цикла.
  int i = 0;

  // находим остаток от деления общего числа итераций на количество итераций
  // в одной итерации развернутого цикла и совершаем переход к этой итерации
  // внутрь тела развернутого цикла.
  switch (number % 4) {
    case 0: 
      do {  
        ++i;
    case 3: ++i; // <- наш случай. Выполнение цикла начнется отсюда и при первой итерации развернутого цикла будет совершено не четыре, а только три итерации исходного цикла (11 % 4 итераций).
    case 2: ++i; 
    case 1: ++i; 
      } while (count-- > 0); 
  }
  
  std::cout << i;
}
```


</div></div>


Ну и ниже описано разъяснение как от метода Даффа пришли к корутинам и асинхронным функциям


<div class="transclusion internal-embed is-loaded"><div class="markdown-embed">



# Как пришли к этому

 Знаменитый «приём Даффа» в языке C использует тот факт что цикл работает правильно несмотря на нестандартный вход в цикл через switch/case. Том Дафф использовал это для оптимизированного цикла вывода. Мы можем использовать это немного иначе. 

```c
int function(void) {
    static int i, state = 0;
    switch (state) {
        case 0: /* start of function */
        for (i = 0; i < 10; i++) {
            state = 1; /* so we will come back to "case 1" */
            return i;
            case 1:; /* resume control straight after the return */
        }
    }
}
```
При первом вызове функции мы идём по case 0 и меняем значение state. Уже во второй и последующие вызовы мы попадаем в конец цикла и начнём следующюю итерацию. И при выполнении итерации снова выходим. Визуально вот так происходит:
![](https://i.imgur.com/UgoXtA9.png)
Ну а теперь абтрагируем под универсальное использование:
```c
#define DECLARE() int state
#define INIT() state = 0
#define BEGIN switch (state) { \
                      case 0:
#define YIELD(val) do { \
                        state = __LINE__;   \
                        return val;         \
                      case __LINE__:        \
                        ;                   \
                      } while (0)
#define END }
```
Как можно заметить сейчас конструкция yield довольна знакома)

</div></div>


И вот у нас получился синтаксис генераторов. На деле они и являются основным механизмом корутин(асинхронности) - механизм прерывания с сохранением состояния. Подробнее можете на это посмотреть в инете загуглив "yield асинхронность". Там вы встретите примеры ака "строим свою асинхронность генераторами" где генераторы заворачивают в task которые обрабатываются в event loop  и вот получается асинхронная система

[[Public/Index\|Главная страница]]